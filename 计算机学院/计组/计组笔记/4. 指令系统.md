# 指令系统

## 指令系统的发展与性能要求

### 指令系统的发展

#### 分类

- 微指令：微程序级的命令，它属于硬件；

- 宏指令：由若干条机器指令组成的软件指令，它属于软件；

- 机器指令：介于微指令与宏指令之间，通常简称为指令，每一条指令可完成一个独立的算术运算或逻辑运算操作

本章所讨论的指令，是机器指令

按作用分：

**数据传送指令、算术运算指令、逻辑运算指令、程序控制指令**

#### 发展情况

- 复杂指令系统计算机，简称 CISC。
    - 如此庞大的指令系统不但使计算机的研制周期变长，难以保证正确性，不易调试维护，而且由于采用了大量使用频率很低的复杂指令而造成硬件资源浪费。

- 精简指令系统计算机：简称 RISC
    - 人们提出了便于 VLSI 技术实现的精简指令系统计算机。

### 指令系统性能要求

- **完备性：**完备性是指用汇编语言编写各种程序时，指令系统直接提供的指令足够使用，而不必用软件来实现。

- **有效性：**有效性是指利用该指令系统所编写的程序能够高效率地运行。

- **规整性：**规整性包括指令系统的对称性、匀齐性、指令格式和数据格式的一致性。
    - 对称性是指：在指令系统中所有的寄存器和存储器单元都可同等对待，所有的指令都可使用各种寻址方式
    - 匀齐性是指：一种操作性质的指令可以支持各种数据类型
    - 指令格式和数据格式的一致性是指：指令长度和数据长度有一定的关系，以方便处理和存取。
- **兼容性：**系列机各机种之间具有相同的基本结构和共同的基本指令集，因而指令系统是兼容的，即各机种上基本软件可以通用。

## 指令格式

![image-20210313140042554](http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210313140042554.png)

### 操作码

指令的操作码OP表示该指令应进行什么性质的操作。不同的指令用操作码字段的不同编码来表示，每一种编码代表一种指令。

组成操作码字段的位数一般取决于计算机指令系统的规模

### 地址码

<img src="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210313140556330.png" alt="image-20210313140556330" style="zoom:80%;" />

#### 三地址指令

功能描述

- (A1) op (A2)→A3

这种格式虽然省去了一个地址，但指令长度仍比较长，所以只在字长较长的大、中型机中使用，而小型、微型机中很少使用

#### 二地址指令

- 功能描述
    - (A1) op (A2)→A1
- 说明
    - 二地址指令在计算机中得到了广泛的应用，
    - 注意：指令执行之后，A1 中原存的内容已经被新的运算结果替换了

- 二地址地址根据操作数的物理位置分为：
    - SS  存储器-存储器类型
    - RS  寄存器-存储器类型
    - RR  寄存器-寄存器类型

#### 一地址指令

- 功能描述
    - (AC) op (A1) → A1
- 说明
    - 单操作数运算指令，如“+1”、“-1”、“求反”
    - 指令中给出一个源操作数的地址
    - 另一个操作数地址是隐含的

#### 零地址指令

“停机”、“空操作”、“清除”等控制类指令

<img src="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210322171915747.png" alt="image-20210322171915747" style="zoom:80%;" />

## 指令字长度

### 概念

- 指令字长度（一个指令字包含二进制代码的位数）

- 机器字长：计算机能直接处理的二进制数据的位数。
- 分类
    - 单字长指令：指令字长等于一个机器字长
    - 半字长指令：指令字长等于半个机器字长
    - 双字长指令：指令字长等于两个机器字长

### 理解

- **多字长指令**的优缺点

    - 优点：提供足够的地址位来解决访问内存任何单元的寻址问题 ；

    - 缺点：必须两次或多次访问内存以取出一整条指令，降低了 CPU 的运算速度，又占用了更多的存储空间

- **等长指令**

    - 各种指令字长度是相等的，指令字结构简单，且指令字长度是不变的 ；

- **非等长指令**

    - 各种指令字长度随指令功能而异，结构灵活，能充分利用指令长度，但指令的控制较复杂

 ### 指令助记符

- 用3～4个英文字母来表示操作码，一般为英文缩写
- 不同的计算机系统，规定不一样
- 必须用汇编语言翻译成二进制代码

### 指令格式举例

<img src="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210313153644062.png" alt="image-20210313153644062" style="zoom:67%;" />

## 指令和数据的寻址方式

### 指令的寻址方式

- 顺序寻址方式
    - PC + 1

- 跳跃寻址方式

<img src="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210313154155455.png" alt="image-20210313154155455" style="zoom:67%;" />

### 操作数基本寻址方式

形成操作数**有效地址**的方法，称为操作数的寻址方式

<img src="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210313154314344.png" alt="image-20210313154314344" style="zoom:67%;" />

形式地址 + 寻址方式特征位

- 形式地址 A , 也称偏移量， 它是指令字结构中给定的地址量。 

- 寻址方式特征位， 此处由间址位和变址位组成。 
- 如果这条指令无间址和变址的要求， 那么形式地址就是操作数的有效地址。 如果指令中指明要变址或间址变换， 那么形式地址就不是操作数的有效地址， 而要经过指定方式的变换， 才能形成有效地址。 因此， 寻址过程就是把操作数的形式地址， 变换为操作数的有效地址的过程

![image-20210313154636585](http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210313154636585.png)

<img src="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210313154658369.png" alt="image-20210313154658369" style="zoom:80%;" />

#### 隐含寻址

指令中隐含着操作数的地址

如单地址指令的某些运算，隐含了累加器 AC 作为源和目的寄存器

#### 立即寻址

指令的地址字段不操作数地址，而是操作数本身

也就是不用寻址

指令格式：操作码 OP  操作数 A

#### 直接寻址

指令中地址码字段给出的地址 A 就是操作数的有效地址 EA (Effective Address)、

**EA＝A**

<img src="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210313160650656.png" alt="image-20210313160650656" style="zoom:67%;" />

#### 间接寻址

指令的地址码部分给出的地址 A 是操作数地址的地址

**EA＝(A)**

<img src="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210313160951264.png" alt="image-20210313160951264" style="zoom:67%;" />

#### 寄存器寻址

在指令的地址码部分给出 CPU 内某一通用寄存器的编号，指令的操作数存放在相应的寄存器中

**EA = R**

<img src="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210313162422634.png" alt="image-20210313162422634" style="zoom:67%;" />

优点

1. 由于寄存器在CPU的内部，指令在执行时从寄存器中取操作数比访问主存要快得多；

2. 由于寄存器的数量较少，因此寄存器编号所占位数也较少，从而可以有效减少指令的地址码字段的长度。

#### 寄存器间接寻址

为了克服间接寻址中多次访存的缺点，可采用寄存器间接寻址，即将操作数放在主存储器中，而操作数的地址放在某一通用寄存器中，然后在指令的地址码部分给出该通用寄存器的编号

**EA = (R)**

<img src="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210313162559938.png" alt="image-20210313162559938" style="zoom:67%;" />

这种寻址方式的指令较短，并且在取指后只需一次访存便可得到操作数，因此指令执行速度较前述的间接寻址方式要快，也是目前在计算机中使用较为广泛的一种寻址方式

#### 偏移寻址

偏移寻址要求指令中有两个地址字段，至少有一个是显示的

- 必定显示的形式地址 A （一般是一个偏移量 D）
- 一个隐含的引用（一般是一个专用寄存器）

**EA = A + (R)**

##### 相对寻址

由程序计数器 PC 提供基准地址（隐含引用），而指令的地址码部分给出相对的位移量 D，两者相加后作为操作数的有效地址

**EA＝D + (PC)**

<img src="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210313163115499.png" alt="image-20210313163115499" style="zoom:67%;" />

##### 基址寻址

专用寄存器是一个基址寄存器，可以显示可以隐式

基址寄存器的位数可以设置得很长，从而可以在较大的存储空间中寻址

**EA = D + (R)**

<img src="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210313163219858.png" alt="image-20210313163219858" style="zoom: 80%;" />

##### 变址寻址

变址寻址就是将指令的地址码部分给出的基准地址 A 与变址寄存器 R 中的内容相加，以形成操作数的有效地址。

**EA = A + R**

<img src="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210313163842841.png" alt="image-20210313163842841" style="zoom: 80%;" />

#### 段寻址方式

存储空间划分为多段

<img src="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210313164024231.png" alt="image-20210313164024231" style="zoom:80%;" />

#### 堆栈寻址

以先进后出原理存储数据

### 寻址方式举例

<img src="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210313164917780.png" alt="image-20210313164917780" style="zoom: 80%;" />

![image-20210313164931546](http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210313164931546.png)

![image-20210320150116083](http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210320150116083.png)

![image-20210320145606857](http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210320145606857.png)

# 